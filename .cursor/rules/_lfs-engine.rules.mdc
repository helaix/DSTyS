# Sparkflow Local-First Sync Engine (LFS) Rules (_lfs-engine.rules.mdc)

**Purpose:** To define standards for interacting with the chosen Local-First Sync Engine (e.g., `LiveStore.dev`), ensuring consistent state management and real-time communication across the Sparkflow platform.
**Primary LFS Candidate:** `LiveStore.dev` (or a custom/alternative implementation if Spike 1 indicates necessity and feasibility). These rules assume a `LiveStore.dev`-like architecture with a D1 backend for its event log/materialized views.
**Primary References:** Official documentation for the chosen LFS engine, Arch Doc v0.5 (Sections 1.3, 3, 5, 7), PRD v1.5.

---
**Rule ID:** `LFS-001`
**Rule Title:** Schema Definition for LFS Documents and Events
**Applies To:** All LFS data structures
**Purpose:** Ensure type safety, data integrity, and facilitate schema evolution for LFS data.
**Scope:** Data modeling for LFS.
**Guideline:**
    *   All LFS document structures (materialized views) and event schemas MUST be defined using `@effect/schema`. These schemas define the contract for data synced and persisted by the LFS engine (which uses D1 as its backend).
    *   Event schemas SHOULD be versioned (e.g., `HookIdeaAddedV1`, `HookIdeaAddedV2`) to allow for future evolution without breaking existing materializers or clients.
**Rationale:** Critical for maintaining data consistency and enabling safe schema changes over time.
**Reference:** `_effect-ts.rules.mdc` (Rule `EFFECT-TS-002`)

---
**Rule ID:** `LFS-002`
**Rule Title:** LFS Client Usage in Frontend (React)
**Applies To:** Frontend UI components
**Purpose:** Ensure reactive UI and adherence to LFS patterns for client-side state management.
**Scope:** RedwoodSDK `web` side development.
**Guideline:**
    *   Utilize the official React bindings/hooks provided by the chosen LFS engine (e.g., `@livestore/react`'s `useQuery`, `useStore`, `useClientDocument`) for subscribing to LFS data and reflecting it in the UI.
    *   Mutations to LFS state from the client SHOULD primarily be achieved by committing events (e.g., `store.commit(Events.HookIdeaAdded.make(...))`). Direct document mutation might be allowed by the LFS for optimistic UI but the canonical change should be event-driven if the LFS supports event sourcing.
    *   Initialize the LFS client within a React Context Provider (`LiveStoreProvider`), configuring it with the LFS backend endpoint and Clerk authentication token retrieval.
**Rationale:** Provides a standardized and efficient way to build reactive user interfaces.

---
**Rule ID:** `LFS-003`
**Rule Title:** LFS Backend Logic and Persistence (e.g., `LFS_Backend_DO`)
**Applies To:** Server-side LFS components
**Purpose:** Centralize authority, security, and robustness for the LFS backend.
**Scope:** Implementation of the LFS sync point (typically a Durable Object).
**Guideline:**
    *   The server-side component of the LFS (e.g., `LFS_Backend_DO` or a CF Worker managing D1 access for the LFS) is the authority for event validation (against `@effect/schema`), persistence to its D1 backend (`D1_LIVESTORE_BACKEND` event log and/or LFS materialized views), and conflict resolution (if applicable).
    *   It MUST enforce Clerk JWT authentication for all client connections and incoming events/mutations.
    *   All logic within this backend component MUST be implemented using EffectTS for robustness, error handling, and D1 interactions (via an EffectTS Drizzle service for LFS's internal D1 operations).
**Rationale:** Ensures the LFS backend is secure, reliable, and consistent.

---
**Rule ID:** `LFS-004`
**Rule Title:** Durable Objects as LFS Clients
**Applies To:** Stateful backend agents (DOs)
**Purpose:** Enable a reactive mesh architecture where agents respond to and influence shared state.
**Scope:** Design of DOs that interact with LFS.
**Guideline:**
    *   Specialized Durable Objects (e.g., `ContextEngineDO`, `CreativeGenDO`, `RenderManagerDO`) WILL act as LFS clients. They subscribe to relevant LFS documents/collections (e.g., `ActiveProjectMVP` state) to trigger their EffectTS workflows.
    *   DOs WILL publish their results, status updates, or new operational state by committing events or updating documents in the LFS (via its server-side SDK or by calling an EffectTS service that interacts with the LFS backend).
    *   Ensure robust LFS client connection management and error handling within DOs, likely via a shared EffectTS `LfsClientService` Layer.
**Rationale:** Allows backend agents to participate in the real-time state synchronization fabric.

---
**Rule ID:** `LFS-005`
**Rule Title:** Data Scoping and Authorization in LFS
**Applies To:** All LFS data and operations
**Purpose:** Critical for security and multi-tenancy.
**Scope:** LFS schema design and backend logic.
**Guideline:**
    *   All LFS documents and events MUST be designed to be scopable by `organizationId` and/or `userId` (derived from Clerk session). This identifier should be a top-level field or part of the document key.
    *   The LFS backend component MUST enforce these scoping rules rigorously during event processing, document materialization, and query execution to ensure strict data isolation. Client-side queries should also include these scopes.
**Rationale:** Protects user data and ensures users only see data they are authorized to access.

---
**Rule ID:** `LFS-006`
**Rule Title:** LFS Interaction with Cloudflare Workflows
**Applies To:** Cloudflare Workflow activities
**Purpose:** Integrate long-running asynchronous processes with the real-time reactive state layer.
**Scope:** Design of Workflow activities that need to update or be triggered by LFS state.
**Guideline:**
    *   Cloudflare Workflow activities (EffectTS programs running in Workers or DOs) SHOULD publish status updates or results to LFS. This is typically done by the activity calling a Redwood Server Action or a DO method, which then commits an LFS event or updates an LFS document. This allows the UI and other LFS clients to react to Workflow progress.
    *   Cloudflare Workflows MAY be triggered based on LFS events if a DO is subscribing to an LFS document and, upon a specific state change, initiates a Workflow via the `WorkflowOrchestrationService` (EffectTS wrapper for CF Workflows API).
**Rationale:** Enables seamless communication between durable workflows and the reactive UI.

---
**Rule ID:** `LFS-007`
**Rule Title:** Conflict Resolution Strategy
**Applies To:** LFS backend and event/document design
**Purpose:** Ensure data consistency in a distributed environment, especially with concurrent edits.
**Scope:** Design of LFS data models and backend logic.
**Guideline:**
    *   For MVP, assume the LFS engine's default conflict resolution (often last-write-wins based on server-side event timestamping) is sufficient for most operational state.
    *   For critical state or future collaborative features (e.g., multiple users editing the same creative brief), design event schemas and materializers to be CRDT-friendly (Conflict-free Replicated Data Types) or implement explicit conflict resolution logic within the LFS backend or event handlers if the chosen LFS supports custom resolution strategies.
**Rationale:** Prevents data loss or inconsistencies when multiple clients modify the same data.

---
**Rule ID:** `LFS-008`
**Rule Title:** Optimistic Updates in UI
**Applies To:** Frontend UI components
**Purpose:** Improve user experience by making the UI feel instantaneous.
**Scope:** Client-side LFS interactions.
**Guideline:**
    *   Leverage the LFS client's capabilities for optimistic updates in the UI to enhance perceived performance.
    *   Ensure clear visual distinction (e.g., a temporary "pending" state) or rollback mechanisms if an optimistic update is later rejected by the server or superseded by another event.
**Rationale:** Makes the application feel faster and more responsive.

---
**Rule ID:** `LFS-009`
**Rule Title:** Testing LFS Interactions
**Applies To:** Unit and integration tests involving LFS
**Purpose:** Ensure reliability of LFS-dependent logic.
**Scope:** Test development.
**Guideline:**
    *   Unit tests for components/services interacting with LFS MUST use a mocked LFS client Layer (EffectTS) or mock LFS React hooks.
    *   Integration tests SHOULD use a local/test instance of the LFS (with a test D1 backend, possibly using Miniflare) to verify end-to-end sync and reactivity.
    *   Test scenarios for optimistic updates and conflict resolution (if applicable).
**Rationale:** Validates the core real-time functionality of the application.
**Reference:** `_testing.rules.mdc`