---
description: 
globs: *.ts,*.tsx
alwaysApply: false
---


# Effect Schema Usage Guidelines

- **Import Pattern**
  - Import Schema with namespace: `import * as S from 'effect/Schema'`
  - Import other Effect utilities: `import { Data } from 'effect'`

- **Basic Schema Definitions**
  ```typescript
  // String schema
  const StringSchema = S.String
  
  // Number schema
  const NumberSchema = S.Number
  
  // Boolean schema
  const BooleanSchema = S.Boolean
  
  // Array of strings
  const StringArraySchema = S.Array(S.String)
  ```

- **Object Schemas**
  ```typescript
  // Object with properties
  const PersonSchema = S.Struct({
    name: S.String,
    age: S.Number,
    isActive: S.Boolean
  })
  
  // Extending structs with record patterns
  const FlexibleSchema = S.Struct({
    id: S.String,
    // Required fields
  }).pipe(S.extend(S.Record({ key: S.String, value: S.Unknown })))
  ```

- **Union Types**
  ```typescript
  // Union of literals (enum-like)
  const StatusSchema = S.Union(
    S.Literal('pending'),
    S.Literal('in-progress'),
    S.Literal('completed'),
    S.Literal('error')
  )
  ```

- **Nullable Fields**
  ```typescript
  // ✅ DO: Use Union with Literal(null) for nullable fields
  const NullableStringSchema = S.Union(S.Literal(null), S.String)
  
  // ❌ DON'T: Use S.nullable() which doesn't exist
  // const WrongNullableSchema = S.nullable(S.String)
  ```

- **Optional Fields**
  ```typescript
  // Optional field in an object
  const UserSchema = S.Struct({
    name: S.String,
    email: S.optional(S.String)
  })
  ```

- **Type Extraction**
  ```typescript
  // Get TypeScript type from schema
  const Schema = S.Struct({ /* ... */ })
  type Type = S.Schema.Type<typeof Schema>
  ```

- **Tagged Errors**
  ```typescript
  // Custom error types
  export class CustomError extends Data.TaggedError('CustomError')<{
    message: string,
    cause?: unknown
  }> {}
  ```

- **Schema Composition**
  ```typescript
  // Reusing schemas
  const BasicInfoSchema = S.Struct({ /* ... */ })
  const ExtendedInfoSchema = S.Struct({
    basicInfo: BasicInfoSchema,
    additionalInfo: S.optional(S.String)
  })
  ```

- **Common Pitfalls**
  - Capitalization matters: `S.Union`, `S.Literal`, `S.Struct` (not `union`, `literal`, `struct`)
  - No `S.nullable()` method - use `S.Union(S.Literal(null), YourSchema)` instead
  - For optional values, use `S.optional(YourSchema)`
