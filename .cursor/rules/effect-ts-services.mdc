---
description: 
globs: packages/domain/**/*.ts
alwaysApply: false
---
# Effect-TS Service Best Practices

This rule outlines common patterns and best practices for working with Effect-TS services in this codebase. Adhering to these conventions helps maintain consistency, type safety, and readability.

## 1. Service Definition Structure

Follow this structure when defining a new service:

- **Service Interface**: Defines the contract for the service.
  ```typescript
  // Example: apps/sparkflow-web/src/effects/onboarding/brandService.ts
  export interface BrandService {
    getBrandInfo: () => Effect.Effect<BrandInfo, OnboardingError | StorageError>;
    setBrandInfo: (brandInfo: BrandInfo) => Effect.Effect<void, OnboardingError | StorageError>;
  }
  ```

- **Service Handle Interface**: A unique symbol for the service, used with `Context.GenericTag`.
  ```typescript
  // Example: apps/sparkflow-web/src/effects/onboarding/brandService.ts
  export interface BrandServiceHandle { readonly _: unique symbol; }
  ```

- **Service Tag**: Created using `Context.GenericTag` with the handle and service interface. This is what's used for dependency injection.
  ```typescript
  // Example: apps/sparkflow-web/src/effects/onboarding/brandService.ts
  export const BrandServiceTag = Context.GenericTag<BrandServiceHandle, BrandService>("BrandService");
  ```

- **Service Implementation Class**: Implements the service interface.
  ```typescript
  // Example: apps/sparkflow-web/src/effects/onboarding/brandService.ts
  export class BrandServiceImpl implements BrandService {
    // ... constructor and method implementations ...
  }
  ```

- **Creator Function (Optional but Recommended)**: A simple function to instantiate the service implementation. Useful for layers.
  ```typescript
  // Example: apps/sparkflow-web/src/effects/onboarding/brandService.ts
  export const createBrandService = (storage: DurableObjectStorage): BrandService => {
    return new BrandServiceImpl(storage);
  };
  ```

- **Live Layer**: Provides the live implementation of the service. Dependencies should be injected using their respective Tags.
  ```typescript
  // Example: apps/sparkflow-web/src/effects/onboarding/brandService.ts
  export const BrandServiceLive = Layer.effect(
    BrandServiceTag, // The Tag for the service being provided
    Effect.map(
      DurableObjectStorageTag, // The Tag for the dependency
      (storage) => createBrandService(storage)
    )
  );
  // For multiple dependencies:
  // export const MyServiceLive = Layer.effect(
  //   MyServiceTag,
  //   Effect.all([Dep1Tag, Dep2Tag]).pipe(
  //     Effect.map(([dep1, dep2]) => createMyService(dep1, dep2))
  //   )
  // );
  ```
  *Refer to [brandService.ts](mdc:apps/sparkflow-web/src/effects/onboarding/brandService.ts) and [durableObjectStorage.ts](mdc:apps/sparkflow-web/src/effects/storage/durableObjectStorage.ts) for concrete examples.*

## 2. Handling `this` Context in `Effect.gen`

When using `Effect.gen` (or `function*`) within a class method that needs to access class members (`this.property` or `this.method()`), `this` can become rebound or lost.

- **✅ DO**: Assign `this` to a variable (e.g., `self`) at the beginning of the method and use `self` within the generator function.
  ```typescript
  // Example: apps/sparkflow-web/src/effects/onboarding/socialService.ts
  import { Effect } from "effect";
  import { BrandService, BrandServiceTag } from "./brandService"; // Assuming BrandService definition

  class MyExampleService {
    constructor(private readonly brandService: BrandService) {}

    discoverInfo(): Effect.Effect<string, Error> {
      const self = this; // Assign this to self
      return Effect.gen(function* (_) {
        const brandInfo = yield* _(self.brandService.getBrandInfo()); // Use self
        // ...
        return `Brand: ${brandInfo.name}`;
      });
    }
  }
  ```
- **❌ DON'T**: Use `this` directly inside the `Effect.gen` callback if it refers to class members, as it might lead to runtime errors or `this` being `any`.

## 3. Error Handling and Types

- **Define Custom Errors**: Use `Data.TaggedError` for custom error types to leverage Effect's typed error channels.
  ```typescript
  // Example from: apps/sparkflow-web/src/effects/core/errors.ts
  import { Data } from "effect";

  export class MyCustomError extends Data.TaggedError("MyCustomError")<{
    readonly message: string;
    readonly context?: unknown; // Add specific context fields as needed
  }> {}
  ```

- **Specify Error Channels**: Service interface methods should clearly define all possible error types in their Effect signature.
  ```typescript
  // Interface example
  interface MyService {
    doSomething: () => Effect.Effect<string, MyCustomError | AnotherError>;
  }
  ```

- **Map or Propagate Errors**:
    - If a service implementation calls another service (or a function returning an Effect) that can fail with an error not declared in its own interface, explicitly map that error to one of its declared error types using `Effect.mapError`.
    - Alternatively, include the dependency's error type in the service's own error channel if it's a meaningful error to expose.
  ```typescript
  // Example from: apps/sparkflow-web/src/effects/onboarding/socialService.ts
  // (Illustrative snippet)
  // Assuming validateSocialPages can return SocialValidationError
  // And discoverSocialPages contract only allows OnboardingError

  // return yield* _(validateSocialPages(discoveredPages).pipe(
  //   Effect.mapError((err: OnboardingError | SocialValidationError) => {
  //     if (err._tag === "SocialValidationError") {
  //       return new OnboardingError({ message: `Validation failed: ${err.message}`, cause: err });
  //     }
  //     return err; // Already OnboardingError
  //   }))
  // );
  ```

## 4. Imports

- Ensure Tags (e.g., `MyServiceTag`) are imported when used as dependencies in Layers, not just the interface type.
- Import specific error types needed by a service.

By following these guidelines, we can build more robust, maintainable, and type-safe Effect-TS applications.
