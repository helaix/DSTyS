# Sparkflow Backend API & Logic Rules (_backend-api.rules.mdc)

**Purpose:** To define standards for backend API development, including Redwood Server Actions, Durable Objects, Cloudflare Queues, Cloudflare Workflows, D1 database interactions, and AI Gateway usage, all within the EffectTS paradigm.
**Primary References:** Architecture Document v0.5, EffectTS Rules (`_effect-ts.rules.mdc`), Cloudflare Docs (Workers, DOs, D1, R2, Vectorize, Queues, Workflows, AI Gateway, Containers), Clerk Documentation, RedwoodSDK Server Action Documentation.

---
**Rule ID:** `API-001`
**Rule Title:** Redwood Server Actions as Primary Command Interface
**Applies To:** Client-to-server command execution
**Purpose:** Provide a type-safe, secure, and EffectTS-idiomatic way for clients to interact with backend logic for commands and mutations.
**Scope:** Implementation of Server Actions in `apps/sparkflow-rw/api/src/services/`.
**Guideline:**
    *   Redwood Server Actions are the primary mechanism for client-initiated commands, mutations, or queries that do not fit a pure Local-First Sync Engine (LFS) document update model.
    *   All Server Action handlers MUST be implemented as EffectTS programs. The handler function itself will be the entry point to run this Effect using the global Effect runtime (e.g., `Effect.runPromise(Effect.provideLayer(myActionEffect(input), AppServicesLiveLayer))`).
    *   Inputs to Server Actions MUST be validated using `@effect/schema` (`Schema.decodeUnknown` or `Schema.parse`) at the beginning of the action's execution.
    *   Server Actions SHOULD be designed to be idempotent where feasible, especially for critical mutating operations.
    *   All Server Actions MUST be authenticated using Clerk JWTs, with user context (`userId`, `orgId`) extracted and propagated to underlying EffectTS services via the Effect's requirement layer (`R`).
    *   Server Actions are a preferred method for triggering Cloudflare Workflows for complex, asynchronous background tasks, using an EffectTS `WorkflowOrchestrationService`.
    *   EffectTS errors from services MUST be caught and transformed into user-friendly, structured error responses (defined by an error schema) before being returned by the Server Action.
**Rationale:** Standardizes client-server command patterns with EffectTS.

---
**Rule ID:** `API-002`
**Rule Title:** Durable Objects (DOs) for Stateful Agents & Specialized Logic
**Applies To:** Stateful backend components
**Purpose:** Leverage DOs for their unique capabilities in stateful serverless computing within the EffectTS paradigm.
**Scope:** Design and implementation of Durable Objects.
**Guideline:**
    *   DOs are used for implementing stateful AI agents (e.g., `ConciergeAgentDO`, `ContextEngineDO`, `CreativeGenDO`, `RenderManagerDO`), orchestrating long-running EffectTS programs that require durable state beyond a single request, managing alarms for scheduled tasks, acting as LFS clients/peers for specific state domains, and serving as stateful activities within Cloudflare Workflows.
    *   All significant logic within DO methods (including `fetch` handlers, alarms, and methods called by Workflow activities) MUST execute EffectTS programs. The DO class acts as a host for the Effect runtime and Layers providing DO-specific context/storage.
    *   Manage DO internal state carefully. Persist critical, strongly consistent state internal to a DO's operation using DO storage (`ctx.storage`). Operational state relevant to UI or other agents MUST be published to and potentially subscribed from the LFS via an EffectTS `LfsClientService`.
    *   DOs can be invoked as activities by Cloudflare Workflows. Methods intended for Workflow invocation MUST accept `@effect/schema`-defined inputs and return JSON-serializable outputs (or serialized `Exit`).
    *   Consider the 'DO as Workflow Manager' pattern for orchestrating multiple Cloudflare Workflow instances if complex lifecycle management is needed (see Arch Doc v0.5).
    *   The `RenderManagerDO` is a specialized DO responsible for managing Cloudflare Containers running Remotion.
**Rationale:** Provides a robust model for stateful serverless actors.

---
**Rule ID:** `API-003`
**Rule Title:** D1 Application Database (`D1_APP_DATA`) Interactions
**Applies To:** Persistence of application-specific relational data
**Purpose:** Ensure type-safe, maintainable, and secure database interactions.
**Scope:** All backend services interacting with `D1_APP_DATA`.
**Guideline:**
    *   All interactions with `D1_APP_DATA` (Sparkflow's application-specific relational data like video metadata, RAG indexes, lineage, templates) MUST be performed via Drizzle ORM, wrapped within EffectTS services (e.g., `D1AppDbService`).
    *   D1 table schemas are defined using Drizzle Kit, informed by `@effect/schema` definitions for data entities.
    *   All D1 queries MUST be scoped by `organizationId` and/or `userId` where appropriate to ensure data isolation, enforced by the EffectTS service layer.
    *   Database migrations MUST be managed using Drizzle Kit and integrated into the CI/CD pipeline.
**Rationale:** Standardizes database access patterns and ensures data integrity.

---
**Rule ID:** `API-004`
**Rule Title:** Cloudflare Queues for Decoupling & Workflow Triggering
**Applies To:** Asynchronous task offloading and simple background jobs
**Purpose:** Improve system resilience and responsiveness by offloading work.
**Scope:** Design of asynchronous task processing.
**Guideline:**
    *   Use Cloudflare Queues for:
        1.  Decoupling time-consuming but non-critical tasks from synchronous request paths (e.g., batch RAG ingestion).
        2.  Triggering Cloudflare Workflows based on specific events or batched inputs.
        3.  Simple, stateless background jobs that don't require complex orchestration.
    *   Queue message payloads MUST be defined with `@effect/schema` for type safety and validation by the consumer.
    *   EffectTS programs running in Cloudflare Worker Queue handlers MUST process messages, including robust error handling and dead-letter queue (DLQ) strategies.
**Rationale:** Provides a reliable mechanism for asynchronous task execution.

---
**Rule ID:** `API-005`
**Rule Title:** Cloudflare Workflows for Complex Asynchronous Orchestration
**Applies To:** Multi-step, long-running, stateful asynchronous processes
**Purpose:** Provide robust, observable, and scalable orchestration for complex backend operations.
**Scope:** Design and implementation of durable backend processes.
**Guideline:**
    *   Cloudflare Workflows (defined as TypeScript classes extending `WorkflowEntrypoint`) are the **primary and preferred** method for orchestrating multi-step, long-running, stateful, and potentially fallible asynchronous processes (e.g., video analysis pipelines, complex creative generation sequences, autonomous campaign lifecycles).
    *   Workflow activities (`step.do(name, callback)`) MUST execute EffectTS programs (running in Workers or DOs).
    *   Utilize Workflow features like `step.sleep`, `step.waitForEvent`, and configure activity retries/timeouts appropriately.
    *   Data passed between workflow steps (input/output of activities) MUST be JSON-serializable and validated with `@effect/schema` within each activity.
    *   Trigger Workflows programmatically via the Cloudflare Workflows API (wrapped in an EffectTS `WorkflowOrchestrationService`), from Queue messages, or via cron triggers (defined in IaC).
    *   Workflow definitions (compiled JS/Wasm) MUST be deployed via IaC.
    *   Important status updates pertinent to the UI MUST be published to LFS by Workflow activities.
**Rationale:** Enables the creation of resilient and complex background job orchestrations.
**Reference:** `_effect-ts.rules.mdc` (Rule `EFFECT-TS-009`)

---
**Rule ID:** `API-006`
**Rule Title:** Cloudflare AI Gateway for External AI API Calls
**Applies To:** All interactions with third-party AI services
**Purpose:** Centralize management, improve observability, and help control costs for AI service usage.
**Scope:** AI service integration.
**Guideline:**
    *   All external AI API calls (Gemini, OpenAI, ElevenLabs, etc.) MUST be routed through the Cloudflare AI Gateway.
    *   Configure AI Gateway for caching (where appropriate), rate limiting, logging, and cost monitoring for these services. This configuration MUST be managed via IaC.
    *   EffectTS services wrapping AI API clients (e.g., `GeminiVideoService`, `TextGenerationService`) SHOULD use the AI Gateway endpoint.
**Rationale:** Provides a control plane for AI API consumption.

---
**Rule ID:** `API-007`
**Rule Title:** Cloudflare Containers for Remotion Rendering (via `RenderManagerDO`)
**Applies To:** Programmatic video rendering
**Purpose:** Consolidate rendering on Cloudflare infrastructure, managed by a dedicated stateful actor for robustness.
**Scope:** Video generation pipeline.
**Guideline:**
    *   Remotion video rendering MUST be executed within Cloudflare Containers, managed and orchestrated by the `RenderManagerDO`.
    *   `RenderManagerDO` is responsible for:
        1.  Receiving render requests (typically from `CreativeGenDO` or a Workflow activity).
        2.  Programmatically starting/managing Cloudflare Container instances (via CF Container API wrapped in an EffectTS `CFContainerService` it depends on).
        3.  Proxying render parameters and assets (e.g., R2 paths) to the Remotion server running inside the container.
        4.  Monitoring render progress (e.g., via container logs, or a callback mechanism if the Remotion app supports it).
        5.  Handling render outputs (ensuring video is written to R2) and errors.
        6.  Publishing final render status and asset links to the LFS.
    *   Container images for Remotion MUST be optimized for size, startup time, and security. Configuration (image name, resources) MUST be managed via IaC.
**Rationale:** Enables scalable and manageable video rendering.
**Reference:** `_creative-gen.rules.mdc` (Rule `CREGEN-003`)